<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neeraj Aim Training</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Orbitron for Sci-Fi look -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&display=swap" rel="stylesheet">
    <!-- MediaPipe Hands & Drawing Utils -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #030508; /* Deep black-blue */
            font-family: 'Orbitron', sans-serif; /* Futuristic Font */
            overflow: hidden;
            user-select: none;
            /* Cyberpunk Grid Background */
            background-image: 
                linear-gradient(rgba(0, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #input_video { display: none; }

        #output_canvas {
            width: 100%;
            height: 100%;
            transform: scaleX(-1); /* Mirror effect */
            display: block;
        }

        /* UI Overlay - Not mirrored */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 24px;
        }

        /* Sci-Fi HUD Panels */
        .hud-panel {
            background: rgba(0, 20, 40, 0.7);
            border-left: 4px solid #00f0ff; /* Neon Cyan */
            padding: 12px 24px;
            color: #e0f2fe;
            position: relative;
            clip-path: polygon(0 0, 100% 0, 100% 80%, 90% 100%, 0 100%); /* Angled cut */
            backdrop-filter: blur(8px);
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.1);
        }
        
        /* Decorative line under stats */
        .hud-panel::after {
            content: '';
            position: absolute;
            bottom: 0;
            right: 0;
            width: 20px;
            height: 2px;
            background: #00f0ff;
        }

        .stat-label { 
            font-size: 0.75rem; 
            color: #00f0ff; 
            text-transform: uppercase; 
            letter-spacing: 0.1em;
            margin-bottom: 4px;
        }
        .stat-value { 
            font-size: 2.5rem; 
            font-weight: 700; 
            line-height: 1;
            text-shadow: 0 0 10px rgba(0, 240, 255, 0.5);
        }

        #center-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            z-index: 50;
            pointer-events: auto; /* Allow clicking buttons */
            width: 100%;
            max-width: 600px;
        }

        /* Cyberpunk Button */
        .btn-primary {
            background: linear-gradient(135deg, #00f0ff 0%, #0066ff 100%);
            color: #000;
            padding: 16px 40px;
            font-size: 1.5rem;
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            border: none;
            cursor: pointer;
            transition: all 0.3s;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            overflow: hidden;
        }
        
        .btn-primary:hover {
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(0, 240, 255, 0.6);
            color: white;
        }

        /* Pinch Indicator Style */
        .crosshair-indicator {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 16px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #333;
            border-radius: 50px; /* Pill shape */
            padding: 10px 24px;
            clip-path: none; /* Reset clip path for this one */
            border-left: none;
        }
        
        .indicator-dot { 
            width: 16px; 
            height: 16px; 
            border-radius: 50%; 
            background: #333; 
            border: 2px solid #555;
            transition: all 0.1s; 
        }
        .indicator-dot.active { 
            background: #00f0ff; 
            border-color: #fff;
            box-shadow: 0 0 15px #00f0ff; 
        }

        /* Custom Card for Results */
        .glass-card {
            background: rgba(10, 15, 25, 0.9);
            border: 1px solid #00f0ff;
            box-shadow: 0 0 30px rgba(0, 240, 255, 0.15);
        }

    </style>
</head>
<body>

<div id="game-container">
    <video id="input_video" playsinline></video>
    <canvas id="output_canvas"></canvas>

    <div id="ui-layer">
        <!-- Top HUD -->
        <div class="flex justify-between items-start w-full">
            <div class="hud-panel">
                <div class="stat-label">Score</div>
                <div class="stat-value" id="score">0</div>
            </div>
            
            <div class="hud-panel flex flex-col items-center" style="border-left: none; border-top: 4px solid #ff0055;">
                <div class="stat-label" style="color: #ff0055;">Time Remaining</div>
                <div class="stat-value" id="timer" style="text-shadow: 0 0 10px rgba(255, 0, 85, 0.5);">60</div>
            </div>

            <div class="hud-panel text-right">
                <div class="stat-label">Accuracy</div>
                <div class="stat-value" id="accuracy">100%</div>
            </div>
        </div>

        <!-- Bottom Helper -->
        <div class="crosshair-indicator">
            <div id="pinch-indicator" class="indicator-dot"></div>
            <span class="text-sm font-bold tracking-widest text-gray-300">PINCH TO SHOOT</span>
        </div>
    </div>

    <!-- Central Overlay -->
    <div id="center-message">
        <!-- Glitch Effect Text -->
        <h1 class="text-6xl md:text-7xl font-black mb-4 tracking-tighter text-white" style="text-shadow: 4px 4px 0px #00f0ff;">
            NEERAJ<br>
            <span class="text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-600" style="text-shadow: none;">AIM TRAINING</span>
        </h1>
        
        <p id="loading-text" class="text-xl text-cyan-200 mb-8 animate-pulse font-mono">> INITIALIZING SYSTEM...</p>
        
        <div id="start-screen" class="hidden">
            <div class="flex gap-6 justify-center mb-10">
                <div class="bg-black/50 p-6 border border-cyan-900/50 rounded-none clip-path-polygon">
                    <div class="text-4xl mb-2">ðŸ‘†</div>
                    <div class="text-xs font-bold text-cyan-400 tracking-widest">AIM</div>
                </div>
                <div class="bg-black/50 p-6 border border-cyan-900/50 rounded-none">
                    <div class="text-4xl mb-2">ðŸ‘Œ</div>
                    <div class="text-xs font-bold text-cyan-400 tracking-widest">SHOOT</div>
                </div>
            </div>
            <button class="btn-primary" onclick="startGame()">INITIATE SESSION</button>
        </div>

        <div id="game-over-screen" class="hidden">
            <div class="text-4xl font-bold mb-6 text-white tracking-widest border-b border-cyan-500 inline-block pb-2">SESSION COMPLETE</div>
            
            <div class="glass-card p-8 mb-8 text-left max-w-lg mx-auto relative overflow-hidden">
                <!-- Decorative scanline -->
                <div class="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-transparent via-cyan-500 to-transparent opacity-50"></div>

                <div class="grid grid-cols-2 gap-8">
                    <div>
                        <div class="stat-label">Final Score</div>
                        <div class="text-4xl font-bold text-cyan-400" id="final-score" style="text-shadow: 0 0 10px rgba(0,255,255,0.5)">0</div>
                    </div>
                    <div>
                        <div class="stat-label" style="color:#ff0055">Avg Reaction</div>
                        <div class="text-3xl font-bold text-white" id="final-reaction">0ms</div>
                    </div>
                    <div>
                        <div class="stat-label" style="color:#00ff99">Hits</div>
                        <div class="text-2xl font-bold text-gray-200" id="final-hits">0</div>
                    </div>
                    <div>
                        <div class="stat-label" style="color:#ff5555">Misses</div>
                        <div class="text-2xl font-bold text-gray-200" id="final-misses">0</div>
                    </div>
                </div>
            </div>
            <button class="btn-primary" onclick="startGame()">REBOOT SYSTEM</button>
        </div>
    </div>
</div>

<script>
    // --- Configuration ---
    const TARGET_RADIUS = 35; // Pixel radius of targets
    const GAME_DURATION = 60; // Seconds
    const MAX_TARGETS = 3;    // Max concurrent targets
    
    // --- State ---
    let gameState = {
        isPlaying: false,
        score: 0,
        timeLeft: GAME_DURATION,
        shotsFired: 0,
        shotsHit: 0,
        targets: [], // {x, y, radius, createdAt, id}
        particles: [],
        cursor: { x: 0.5, y: 0.5, isPinched: false, wasPinched: false },
        lastTime: 0
    };

    // --- DOM ---
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const scoreEl = document.getElementById('score');
    const timerEl = document.getElementById('timer');
    const accuracyEl = document.getElementById('accuracy');
    const pinchIndicator = document.getElementById('pinch-indicator');
    
    // Screens
    const loadingText = document.getElementById('loading-text');
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const centerMessage = document.getElementById('center-message');

    // Stats
    const finalScoreEl = document.getElementById('final-score');
    const finalHitsEl = document.getElementById('final-hits');
    const finalMissesEl = document.getElementById('final-misses');
    const finalReactionEl = document.getElementById('final-reaction');

    function resizeCanvas() {
        canvasElement.width = window.innerWidth;
        canvasElement.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // --- MediaPipe Setup ---
    window.onload = function() {
        if (typeof Hands === 'undefined') {
            loadingText.innerText = "Error loading MediaPipe. Check connection.";
            return;
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.6, // Higher confidence for stability
            minTrackingConfidence: 0.6
        });

        hands.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 1280,
            height: 720
        });

        camera.start().then(() => {
            loadingText.style.display = 'none';
            startScreen.classList.remove('hidden');
        }).catch(err => {
            loadingText.innerText = "Camera Access Denied";
        });
    };

    // --- Core Tracking Logic ---
    function onResults(results) {
        // Draw Video Background
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        
        // Darken video slightly for better UI contrast
        canvasCtx.filter = 'brightness(0.7) contrast(1.1)';
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.filter = 'none';

        // Add subtle scanline overlay
        canvasCtx.fillStyle = "rgba(0, 20, 40, 0.2)";
        canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            updateCursor(landmarks);
        }

        if (gameState.isPlaying) {
            updateGame(performance.now());
        }

        drawGame();
        canvasCtx.restore();
    }

    function updateCursor(landmarks) {
        // 1. Get Coordinates (Index Tip #8)
        const indexTip = landmarks[8];
        const thumbTip = landmarks[4];

        // Smooth cursor movement (Lerp)
        const lerpFactor = 0.4;
        gameState.cursor.x = gameState.cursor.x + (indexTip.x - gameState.cursor.x) * lerpFactor;
        gameState.cursor.y = gameState.cursor.y + (indexTip.y - gameState.cursor.y) * lerpFactor;

        // 2. Pinch Detection (Euclidean distance between Index Tip and Thumb Tip)
        // Since x is normalized to aspect ratio, we adjust dx by aspect ratio for true distance visual
        const aspectRatio = canvasElement.width / canvasElement.height;
        const dx = (indexTip.x - thumbTip.x) * aspectRatio; // Correct for non-square
        const dy = indexTip.y - thumbTip.y;
        const distance = Math.sqrt(dx*dx + dy*dy);

        // Thresholds
        const PINCH_THRESHOLD = 0.06; // Adjust based on testing
        const RELEASE_THRESHOLD = 0.08;

        // Hysteresis to prevent flickering
        if (distance < PINCH_THRESHOLD) {
            if (!gameState.cursor.isPinched) {
                gameState.cursor.isPinched = true;
                handleInput(); // Trigger Click
            }
        } else if (distance > RELEASE_THRESHOLD) {
            gameState.cursor.isPinched = false;
        }

        // Update UI Indicator
        if (gameState.cursor.isPinched) {
            pinchIndicator.classList.add('active');
        } else {
            pinchIndicator.classList.remove('active');
        }
    }

    // --- Game Logic ---
    function startGame() {
        startScreen.classList.add('hidden');
        gameOverScreen.classList.add('hidden');
        centerMessage.style.pointerEvents = 'none'; // Click through overlay

        gameState = {
            isPlaying: true,
            score: 0,
            timeLeft: GAME_DURATION,
            shotsFired: 0,
            shotsHit: 0,
            targets: [],
            particles: [],
            cursor: gameState.cursor, // Keep cursor state
            startTime: Date.now()
        };

        // Spawn initial targets
        for(let i=0; i<3; i++) spawnTarget();

        // Start Timer Interval
        if (window.gameTimer) clearInterval(window.gameTimer);
        window.gameTimer = setInterval(() => {
            gameState.timeLeft--;
            timerEl.innerText = gameState.timeLeft;
            if (gameState.timeLeft <= 0) endGame();
        }, 1000);
    }

    function spawnTarget() {
        if (gameState.targets.length >= MAX_TARGETS) return;

        // Random position with padding (10% - 90%)
        const x = 0.1 + Math.random() * 0.8;
        const y = 0.1 + Math.random() * 0.8;
        
        gameState.targets.push({
            x: x,
            y: y,
            radius: 0, // Animate in
            targetRadius: TARGET_RADIUS / canvasElement.width, // Normalized radius
            createdAt: Date.now(),
            id: Math.random()
        });
    }

    function handleInput() {
        if (!gameState.isPlaying) return;

        gameState.shotsFired++;
        let hit = false;
        const w = canvasElement.width;
        const h = canvasElement.height;

        // Check collision with targets
        // Iterate backwards to safely remove
        for (let i = gameState.targets.length - 1; i >= 0; i--) {
            const t = gameState.targets[i];
            
            // Distance check
            // Note: cursor.x matches t.x (normalized)
            const dx = (gameState.cursor.x - t.x) * w;
            const dy = (gameState.cursor.y - t.y) * h;
            const dist = Math.sqrt(dx*dx + dy*dy);

            if (dist < TARGET_RADIUS + 10) { // +10 forgiveness
                // HIT!
                hit = true;
                gameState.shotsHit++;
                gameState.score += 100;
                
                // Reaction Bonus (faster = more points)
                const reactionTime = Date.now() - t.createdAt;
                if (reactionTime < 1000) gameState.score += 50;
                
                // VFX
                createParticles(t.x, t.y, '#00f0ff'); // Cyan burst
                createFloatText(t.x, t.y, "+150");

                // Remove and Spawn new
                gameState.targets.splice(i, 1);
                spawnTarget();
                break; // Only hit one target per pinch
            }
        }

        if (!hit) {
            // MISS
            gameState.score = Math.max(0, gameState.score - 20); // Penalty
            createParticles(gameState.cursor.x, gameState.cursor.y, '#ff0055'); // Red/Pink burst
            createFloatText(gameState.cursor.x, gameState.cursor.y, "MISS");
        }

        // Update Stats UI
        scoreEl.innerText = gameState.score;
        const acc = gameState.shotsFired === 0 ? 0 : Math.round((gameState.shotsHit / gameState.shotsFired) * 100);
        accuracyEl.innerText = acc + "%";
    }

    function endGame() {
        gameState.isPlaying = false;
        clearInterval(window.gameTimer);
        
        // Show Results
        centerMessage.style.pointerEvents = 'auto';
        gameOverScreen.classList.remove('hidden');
        
        finalScoreEl.innerText = gameState.score;
        finalHitsEl.innerText = gameState.shotsHit;
        finalMissesEl.innerText = gameState.shotsFired - gameState.shotsHit;
        finalReactionEl.innerText = "N/A"; // Could implement average tracking
    }

    function updateGame(time) {
        // Animate Targets (Pop in)
        gameState.targets.forEach(t => {
            if (t.radius < t.targetRadius) {
                t.radius += (t.targetRadius - t.radius) * 0.2;
            }
        });

        // Update Particles
        for (let i = gameState.particles.length - 1; i >= 0; i--) {
            const p = gameState.particles[i];
            p.life--;
            p.x += p.vx;
            p.y += p.vy;
            if (p.life <= 0) gameState.particles.splice(i, 1);
        }
    }

    // --- Rendering ---
    function drawGame() {
        const w = canvasElement.width;
        const h = canvasElement.height;

        // Draw Targets with Neon Glow
        gameState.targets.forEach(t => {
            const tx = t.x * w;
            const ty = t.y * h;
            const tr = t.radius * w; // Scale radius by width

            canvasCtx.shadowBlur = 20;
            canvasCtx.shadowColor = "#00f0ff";

            // Outer Ring
            canvasCtx.beginPath();
            canvasCtx.arc(tx, ty, tr, 0, Math.PI * 2);
            canvasCtx.strokeStyle = '#00f0ff'; // Neon Cyan
            canvasCtx.lineWidth = 3;
            canvasCtx.stroke();
            
            // Faint fill
            canvasCtx.fillStyle = 'rgba(0, 240, 255, 0.1)';
            canvasCtx.fill();

            // Inner Dot
            canvasCtx.beginPath();
            canvasCtx.arc(tx, ty, tr * 0.3, 0, Math.PI * 2);
            canvasCtx.fillStyle = '#fff';
            canvasCtx.fill();
            
            canvasCtx.shadowBlur = 0; // Reset
        });

        // Draw Particles
        gameState.particles.forEach(p => {
            canvasCtx.fillStyle = p.color;
            canvasCtx.globalAlpha = p.life / 30;
            
            // Glow for particles too
            canvasCtx.shadowBlur = 10;
            canvasCtx.shadowColor = p.color;
            
            canvasCtx.beginPath();
            canvasCtx.arc(p.x * w, p.y * h, p.size, 0, Math.PI * 2);
            canvasCtx.fill();
            
            canvasCtx.globalAlpha = 1.0;
            canvasCtx.shadowBlur = 0;
        });

        // Draw Float Text
        canvasCtx.save();
        canvasCtx.scale(-1, 1); // Flip back for text
        canvasCtx.textAlign = "center";
        canvasCtx.font = "bold 24px 'Orbitron', monospace"; // Larger, tech font
        canvasCtx.shadowBlur = 10;
        
        gameState.particles.forEach(p => {
            if (p.text) {
                // Correct coordinates for flipped context: x becomes -x
                canvasCtx.fillStyle = p.text === "MISS" ? "#ff0055" : "#00f0ff";
                canvasCtx.shadowColor = canvasCtx.fillStyle;
                
                canvasCtx.globalAlpha = p.life / 40;
                canvasCtx.fillText(p.text, -1 * (p.x * w), p.y * h);
            }
        });
        canvasCtx.restore();

        // Draw Cursor (Sci-Fi Crosshair)
        if (gameState.cursor) {
            const cx = gameState.cursor.x * w;
            const cy = gameState.cursor.y * h;
            const isActive = gameState.cursor.isPinched;
            const color = isActive ? '#00f0ff' : '#ffffff';
            const size = isActive ? 15 : 25;

            canvasCtx.shadowBlur = 10;
            canvasCtx.shadowColor = color;

            // Crosshair Lines
            canvasCtx.strokeStyle = color;
            canvasCtx.lineWidth = 2;
            
            // Vertical / Horizontal lines with gap
            const gap = 8;
            canvasCtx.beginPath();
            // Left
            canvasCtx.moveTo(cx - size, cy);
            canvasCtx.lineTo(cx - gap, cy);
            // Right
            canvasCtx.moveTo(cx + gap, cy);
            canvasCtx.lineTo(cx + size, cy);
            // Top
            canvasCtx.moveTo(cx, cy - size);
            canvasCtx.lineTo(cx, cy - gap);
            // Bottom
            canvasCtx.moveTo(cx, cy + gap);
            canvasCtx.lineTo(cx, cy + size);
            canvasCtx.stroke();

            // Center Dot
            canvasCtx.beginPath();
            canvasCtx.arc(cx, cy, 2, 0, Math.PI * 2);
            canvasCtx.fillStyle = color;
            canvasCtx.fill();

            // Ring (if pinching - target lock style)
            if (isActive) {
                canvasCtx.beginPath();
                canvasCtx.arc(cx, cy, 20, 0, Math.PI * 2);
                canvasCtx.strokeStyle = '#00f0ff';
                canvasCtx.lineWidth = 3;
                canvasCtx.setLineDash([5, 5]); // Dashed line for tech look
                canvasCtx.stroke();
                canvasCtx.setLineDash([]);
            }
            
            canvasCtx.shadowBlur = 0;
        }
    }

    function createParticles(x, y, color) {
        for(let i=0; i<10; i++) { // More particles
            gameState.particles.push({
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 0.015,
                vy: (Math.random() - 0.5) * 0.015,
                life: 20 + Math.random() * 15,
                size: 2 + Math.random() * 4,
                color: color
            });
        }
    }

    function createFloatText(x, y, text) {
        gameState.particles.push({
            x: x,
            y: y,
            vx: 0,
            vy: -0.002, // Float up
            life: 40,
            size: 0,
            color: 'white',
            text: text
        });
    }

</script>
</body>
</html>